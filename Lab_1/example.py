# -*- coding: utf-8 -*-
"""lab1.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/16NfQBkVey-gJoKIsFEwNzg1uxFAVUlwC

# Лабораторная работа 1. Введение в цифровую обработку изображений.

В этой работе рассматриваются базовые операции линейной алгебры, NumPy и OpenCV.

Цель лабораторной работы: получить навыки работы с линейной алгеброй и базовыми операциями с изображениями в Python.


#

Настроим Jupyter на отображение полного интерактивного вывода:

#

from IPython.core.interactiveshell import InteractiveShell

InteractiveShell.ast_node_interactivity = "all"

# 1. NumPy

NumPy -- библиотека, предоставляющая реализации алгоритмов, оптимизированных для работы с многомерными массивами. NumPy основан на библиотеке LAPACK, что делает вычисления быстрыми.

Кроме базового варианта (многомерные массивы в базовом варианте) NumPy включает в себя набор пакетов для решения специализированных задач, например:

- numpy.linalg — реализует операции линейной алгебры (простое умножение векторов и матриц есть в базовом варианте);
- numpy.random — реализует функции для работы со случайными величинами.

NumPy Array vs Python List:
- NumPy быстрее чем обычные списки в случаях, когда операции могут быть векторизованы.
- Добавление элементов в существующий массив медленнее в NumPy, по сравнению с Python List. Операция добавления элемента в массив NumPy имеет сложность O(N), а в Python List -- O(1).
- Массивы NumPy могут работать с элементами только одного типа.

Документацию по NumPy можно найти [здесь](https://numpy.org/devdocs/reference/index.html#reference)

## 1.1 Установка и подключение библиотеки
Для установки библиотеки NumPy выполнить команду ниже. Восклицательный знак позволяет выполнять команды терминала в Jupyter Notebook. Для выполнения команды в терминале восклицательный знак нужно убрать.
"""

## !pip3 install numpy

"""### Подключение библиотеки в коде
Для использования библиотеки NumPy сначала подключим ее.
"""

import numpy as np

"""## 1.2 Создание массивов
Существуют несколько способов создания массивов.

### 1.2.1. Создание массива из списка

**Создание векторов:**
"""


a = np.array([1, 2, 3])  # int32 array
b = np.array([1., 2., 3.])  # float64 array
c = np.array([1, 2, 3], int)  # int32 array
d = np.array([1, 2, 3], float)  # float64 array
e = np.array([1, 2, 3], np.dtype('f'))  # float32 array
print(a)

"""Больше про типы можно прочитать в [документации](https://numpy.org/doc/stable/reference/arrays.dtypes.html).

**Создание матриц:**
"""

f = np.array([[1., 2., 3.],
              [4., 5., 6.],
              [7., 8., 9.]])
print(f)

"""**Создание трехмерного массива:**"""

g = np.array([[[1, 2, 3],
               [4, 5, 6],
               [7, 8, 9]],
              [[11, 12, 13],
               [14, 15, 16],
               [17, 18, 19]]])

"""Подобным образом в NumPy возможно создавать массивы больших размерностей.

### 1.2.2. Создание пустых и заполненных значениями массивов

Массивы NumPy не могут расширяться так, как это делает список Python, т.к. в конце массива не зарезервировано место для быстрого добавления. Поэтому обычной практикой является либо расширение списка Python и преобразование его в массив NumPy, либо предварительное выделение необходимого пространства с помощью `np.zeros` или `np.empty`.
"""

a = np.zeros(3, int)  # нулевой одномерный массив размерности 3
b = np.empty(3, int)  # пустой одномерный массив размерности 3
c = np.ones(3)  # массив, заполненный единицами
d = np.full(3, 7.)  # массив, заполненный значением 7

e = np.zeros_like(a)  # создание нулевого массива, по размерности и типу совпадающего с 'a'
f = np.empty_like(b)  # создание пустого массива, по размерности и типу совпадающего с 'b'
g = np.ones_like(c)  # создание единичного массива, по размерности и типу совпадающего с 'c'
h = np.full_like(d, 8)  # создание заполненного массива, по размерности и типу совпадающего с 'd'
print(b)

"""Чтобы создать массив нужно указать две размерности при помощи кортежа (в скобках):"""

k = np.ones((3, 2))
print(k)

"""Подобным образом, с матрицами работают методы np.zeros(), np.empty(), np.full и их сопутствующие функции np.zeros_like(), np.empty_like(), np.ones_like(), np.full_like().

Для создания единичной матрицы существует метод np.eye():
"""

a = np.eye(3, 3)
print(a)

"""**Инициализация массива последовательностью чисел** осуществляется методами `np.arange()` и `np.linspace()`.
`np.arange(stop)` -- создает массив чисел с последовательностью от 0 до значения stop.
`np.arange(start, stop)` -- создает массив чисел от значения start до значения stop.
`np.arange(start, stop, step)` -- создает массив чисел от start до stop c шагом step.

`np.linspace(start, stop, n)` -- создает массив размерности n со значениями от start до stop. Шаг последовательности вычисляется автоматически.

"""

a = np.arange(6)
b = np.arange(2, 6)
c = np.linspace(0, 0.5, 6)

print('a =', a)
print('b =', b)
print('c =', c)

"""Также возможно создать массив, заполненный случайными значениями:
`rnd = np.random.default_rng()` -- создание генератора
`rnd.integers(min, max, n)` -- возвращает массив  размерности n случайных равномерно расспределенных целых чисел, где x ∈ [min, max).
`rnd.integers(min, max, n, endpoint=True)` -- возвращает массив размерности n случайных равномерно расспределенных целых чисел, где x ∈ [min, max].
`rnd.random(n)` -- возвращает массив размерности n случайных равномерно расспределенных вещественных чисел, где x ∈ [min, max).
`rnd.uniform(min, max, n)` -- возвращает массив размерности n случайных равномерно расспределенных вещественных чисел, где x ∈ [min, max).
`rnd.standard_normal(n)` -- возвращает массив размерности n случайных нормально распределенных вещественных чисел, где μ=0, σ=1.
`rnd.normal(μ, σ, n)` -- возвращает массив размерности n случайных нормально распределенных вещественных чисел с заданными μ и σ.


"""

rnd = np.random.default_rng()
a = rnd.integers(0, 10, 3)
b = rnd.integers(0, 10, 3, endpoint=True)
c = rnd.random(3)
d = rnd.uniform(1, 10, 3)
e = rnd.standard_normal(3)
f = rnd.normal(5, 2, 3)

"""Аналогичным образом можно создать заполненную случайными числами матрицу. Размерность также указывается кортежем (в скобках):

"""

rnd = np.random.default_rng()
a = rnd.integers(0, 10, (3, 2))
b = rnd.integers(0, 10, (3, 2), endpoint=True)
c = rnd.random((3, 2))
d = rnd.uniform(1, 10, (3, 2))
e = rnd.standard_normal((3, 2))
f = rnd.normal(5, 2, (3, 2))

"""### 1.2.3 reshape() -- функция изменение формы массива

функция reshape() позволяет преобразовать одномерный массив в двухмерный (в общем случае в n-мерный) и обратно.
<img height="100" src="../content/reshape.png"/>
"""

a = np.arange(1, 7)
b = a.reshape(2, 3)
c = a.reshape(2, -1)
d = b.reshape(-1)

print('a = ', a, sep='\n')
print('b =', b, sep='\n')
print('c =', c, sep='\n')
print('d =', d, sep='\n')

"""## 1.3 Доступ к данным массива

Обратиться к данным массива можно используя индексацию, в том числе используя срезы.
"""

a = np.arange(1, 6)
print('a =', a)
print('a[1] =', a[1])
print('a[2:4] =', a[2:4])
print('a[-2:] =', a[-2:])
print('a[::2] =', a[::2])

a[0] = 10  # запись в нулевую ячейку значения 10
print('a =', a)

"""Также возможно использовать **булеву индексацию**:
<img alt="boolean_indexing" src="../content/boolean_indexing.png" width="600"/>
"""

a = np.array([1, 2, 3, 4, 5, 6, 7, 6, 5, 4, 3, 2, 1])
b = np.copy(a)
a[a > 5] = 0
b[(b >= 3) & (b <= 5)] = 0
print('a =', a)
print('b =', b)

"""Примеры **индексации элементов матриц**:

<img height="250" src="../content/martix_indexing.png"/>
"""

a = np.arange(1, 13).reshape(3, 4)  # reshape изменяет размерность массива
print('a =\n', a)
print('a[1,2] =', a[1, 2])
print('a[1,:] =', a[1, :])
print('a[1,2] =', a[:, 2])
print('a[:,1:3] =\n', a[:, 1:3])
print('a[-2:,-2:] =\n', a[-2:, -2:])
print('a[::2,1::2] =\n', a[::2, 1::2])

"""### 1.3.1. Копирование элементов массива
Нужно помнить, что массив NumPy является объектом, а значит простое присвоение массива новой переменной копирует не значения массива, а ссылку на объект массива.
Рассмотрим пример:
"""

a = np.array([1, 2, 3])
b = a  # здесь копируется не массив, а ссылка на него!
b[0] = 10  # Теперь изменим первый элемент массива на значение 10 и выведем содержимое a и b.
print('a =', a)
print('b =', b)

""" Для копирования массива следует использовать метод **copy()**."""

a = np.array([1, 2, 3])
b = a.copy()
b[0] = 10
print('a =', a)
print('b =', b)

"""### 1.3.2 Вставка и добавление элементов массива
Для вставки и добавления элементов массива следует использовать методы `insert()` и `append()`
"""

a = np.array([1, 2, 3])
b = np.insert(a, 1, [4, 5, 6])
c = np.append(a, [4, 5, 6])
print('b =', b)
print('c =', c)

"""## 1.4 Векторные операции
NumPy позволяет осуществлять векторные операции, т.е. арифметические, логические операции между вектором (массивом) и числом или двумя векторами, а также операции векторной алгебры.

### 1.4.1 Операции над вектором и числом
"""

a = np.array([1, 2, 3])
b = 3

print('a + b =', a + b)
print('a - b =', a - b)
print('a * b =', a * b)
print('a / b =', a / b)
print('a // b =', a // b)

"""### 1.4.2. Операции над векторами"""

a = np.array([1, 2, 3])
b = np.array([4, 5, 6])

print('a + b =', a + b)
print('a - b =', a - b)
print('a * b =', a * b)
print('a / b =', a / b)
print('a // b =', a // b)

"""### 1.4.3 Математические функции над векторами"""

a = np.array([1, 2, 3])

print('a^2 =', a ** 2)
print('√a =', np.sqrt(a))
print('e^a =', np.exp(a))
print('ln(a) =', np.log(a))
print('sin(a) =', np.sin(a))

"""### 1.4.4. Векторные операции"""

a = np.array([1, 2])
b = np.array([3, 4])

print('a∙b =', np.dot(a, b))
print('a⨉b =', np.cross(a, b))

"""### 1.4.5 Иные функции над векторами
К векторам также возможно применение функций:
- округления: np.floor(), np.ceil(), np.round();
- статистики: np.max(), np.min(), np.sum(), np.mean(), np.std() и др.;
- сортировки: np.sort();
- поиска: np.where();
- сравнения вещественных чисел: np.allclose(), np.isclose()

**Добавьте примеры использования этих функций самостоятельно**.

## 1.5 Матричные операции
NumPy позволяет осуществлять также и матричные операции.
Среди ни нужно отметить следующие:
A * B -- операция поэлементного умножения;
A @ B -- операция матричного умножения;
A / B -- операция матричного деления.
"""

a = np.array([[1, 2], [3, 4]])
b = np.array([[2, 0], [0, 2]])

print('b + a =', b + a, sep='\n')
print('b - a =', b - a, sep='\n')
print('b * a =', b * a, sep='\n')
print('b @ a =', b @ a, sep='\n')
print('b / a =', b / a, sep='\n')
print('b // a =', b // a, sep='\n')

"""### 1.5.1 Транспонирование
Транспонирование матрицы осуществляется двумя способами:
a.transpose() или a.T

**Транспонирование векторов работает иначе**. Если попробовать применить транспонирование, например, к вектору-строке:
    `a = np.array([1, 2, 3])`
    `a.T`
то ничено не изменится. Вектор, как был строкой, так строкой и остался. Это происходит потому, что массив `a` имеет только одну размерность.
Самым простым способом транспонирования, является смена размерности:
`a.reshape(-1, 1)`
здесь -1 -- говорит NumPy вычислять размер автоматически


"""

a = np.array([1, 2, 3])
b = a.reshape(-1, 1)
print(b)
print('a * b =\n', a * b)

"""### 1.5.2 Смешанные операции между вектором и матрицей
NumPy также допускает смешанные операции между вектором и матрицей
<img height="300" src="../content/some_matrix_op.png"/>

"""

a = np.arange(1, 10).reshape(3, 3)
print('a / 9 =', a / 9, sep='\n')
print('a * [-1,0,1] =', a * np.array([-1, 0, 1]), sep='\n')
b = a / (np.array([3, 6, 9]).reshape(-1, 1))
print('a / [3 6 9]T =', b, sep='\n')
print('[1 2 3] * [1 2 3]T =', np.array([1, 2, 3] * np.array([1, 2, 3]).reshape(-1, 1)), sep='\n')
c = np.array([1, 2, 3]).reshape(-1, 1) * np.array([1, 2, 3])
print('c = \n', c)
# print(a / np.array([1, [3, 6, 9]]))

"""### 1.5.3 Манипуляции над матрицами

#### 1.5.3.1 Функции объединения массивов
<img height="300" src="../content/union_matrix.png"/>
"""

a = np.arange(1, 13).reshape(3, -1)
b = np.arange(1, 9).reshape(2, -1)
c = np.arange(1, 7).reshape(3, -1)
print('vstack((a,b)) =', np.vstack((a, b)), sep='\n')
print('hstack((a,c)) =', np.hstack((a, c)), sep='\n')

"""**Функции объединения матрицы с векторами:**

<img height="300" src="../content/union_matrix_and_vector.png"/>

Здесь нужно быть внимательным и помнить, что при операции hstack нужно создать именно вектор-стобец, добавив вторую размерность при помощи метода reshape(-1,1) или c[:, None]. Если нужно использовать именно вектор-строку, то вместо метода hstack() нужно использовать метод column_stack().

"""

a = np.arange(1, 13).reshape(3, -1)
b = np.arange(1, 5)
c = np.array([1, 3, 5])
print('vstack((a,b)) =', np.vstack((a, b)), sep='\n')
print('hstack((a,c)) =', np.hstack((a, c[:, None])), sep='\n')

"""#### 1.5.3.2 Функции расщепления массивов
Обратной операцией объединения массивов (векторов) является операция расщепления массивов (методы `hsplit()` и `vsplit()`).
"""

a = np.arange(1, 13).reshape(3, -1)
b = np.arange(1, 9).reshape(2, -1)
c = np.arange(1, 7).reshape(3, -1)
d = np.vstack((a, b))
e = np.hstack((a, c))
print('vsplit(d,[3])) =', np.vsplit(d, [3]), sep='\n')
print('hsplit((e,[4]])) =', np.hsplit(e, [4]), sep='\n')

"""#### 1.5.3.3 Иные операции манипуляции над массивами
Существуют и другие операции манипуляций над массивами:
- репликация матрицы (`np.tile()`, `np.repeat()`);
- удаление столбцов и строк матрицы (`np.delete()`);
- вставка столбцов и строк матрицы (`np.insert()`);
- добавление столбцов и строк к матрице (`np.append()`);
- добавление граничных значений к матрице (`np.pad()`).

Рассмотрите и создайте примеры их использования самостоятельно.

## 1.6 Сохранение и загрузка данных на диск

### 1.6.1 Сохранение и загрузка NumPy массивов

Для сохранения массивов на накопитель в NumPy предусмотрен метод `np.savez(). Первым аргументом передается название файла. Последующими аргументами указываются данные в виде ключ-значение, где в качестве ключа указывается именование данных в файле, а значением -- имя переменной, хранящей данные.
"""

np.savez("mas.npz", a=a, b=b)
np.savez("mas2.npz", nameOfVar1=a, nameOfVar2=b)

# Commented out IPython magic to ensure Python compatibility.
# %reset_selective [a, b, c, d, e]
# %reset

"""Загрузка массивов осуществляется функцией np.load(), где в качестве аргумента передается имя файла."""

import numpy as np  #снова подключаем numpy

loadMas = np.load("mas.npz")
loadMas2 = np.load("mas2.npz")
print(loadMas.files)
print(loadMas2.files)
a = loadMas["a"]
b = loadMas2["nameOfVar2"]

"""### 1.6.2 Сохранение/загрузка данных в файл MatLAB (.mat)
Для работы с файлами MatLAB нужно подключить библиотеку scipy.
"""

import scipy.io as sio

"""Сохранение данных в файл .mat осуществляется функцией savemat(), где в качестве аргументов передаются название файла и данные в виде ключ-значение"""

sio.savemat('test.mat', {'a': a})

"""Чтение файла .mat осуществляетя функцией loadmat()."""

testMat = sio.loadmat('test.mat')

a = testMat['a']

"""## 1.7 Приведение типов в NumPy
При работе с изображениями, видео или просто с матрицами больших размеров, может требоваться точное управление типами данных. В отличие от чистого Python, который предоставляет лишь несколько числовых типов, NumPy предоставляет более широкий перечень типов.

В NumPy доступны следующие типы данных:

- bool_ - Логический тип (истина или ложь), хранящийся в виде байта.
- int_ - Целочисленный тип установленный по умолчанию (такой же, как C long, как правило это либо int64 либо int32).
- intc - Идентичен C int (int32 или int64).
- intp - Целочисленный тип, используемый для индексирования (такой же, как C ssize_t, как правило это либо int64 либо int32).
- int8 - Целые числа в диапазоне от -128 по 127 (числа размером 1 байт).
- int16 - Целые числа в диапазоне от -32768 по 32767, (числа размером 2 байта).
- int32 - Целые числа в диапазоне от -2147483648 по 2147483647, (числа размером 4 байта).
- int64 - Целые числа в диапазоне от -9223372036854775808 по 9223372036854775807, (числа размером 8 байт).
- uint8 - Целые числа в диапазоне от 0 по 255 (числа размером 1 байт).
- uint16 - Целые числа в диапазоне от 0 по 65535 (числа размером 2 байта).
- uint32 - Целые числа в диапазоне от 0 по 4294967295 (числа размером 4 байта).
- uint64 - Целые числа в диапазоне от 0 по 18446744073709551615 (числа размером 8 байт).
- float_ - То же самое что и float64.
- float16 - Вещественные числа половинной точности: 1 бит знака, 5 бит экспоненты 10 бит мантисы (числа размером 2 байта).
- float32 - Вещественные числа одинарной точности: 1 бит знака, 8 бит экспоненты 23 бита мантисы (числа размером 4 байта).
- float64 - Вещественные числа двойной точности: 1 бит знака, 11 бит экспоненты, 52 бита мантисы (числа размером 8 байт).
- complex_ - То же самое что и complex128.
- complex64 - Комплексные числа в которых действительная и мнимая части представлены двумя вещественными числами типа float32.
- complex128 - Комплексные числа в которых действительная и мнимая части представлены двумя вещественными числами типа float64.

Полный перечень типов можно посмотреть, если вывести содержимое словаря np.sctypeDict.
"""

np.sctypeDict

"""Если импортировать NumPy как `import numpy as np`, то объекты типа данных становятся доступны как np.bool_, np.float64, np.int16 и т.д.

Для преобразования одного типа данных в другой можно так же воспользоваться объектами типа данных:
- np.float64(11)
- np.int64(11)
- np.float64([1, 2, 3])
- np.int16([1, 2, 3])

или воспользоваться методом astype():
"""

a = np.float64([1, 2, 3])
a.astype(np.uint8)

"""
Если нужна информация о каком-то конкретном типе чисел с плавающей запятой, то ее можно запросить с помощью функции finfo():
- np.finfo(np.float64)
- np.finfo(np.floаt)
- np.finfo(np.float16)"""

np.finfo(np.float64)

"""Иногда бывает очень полезно узнать размер массива в байтах:"""

a = np.arange(5, dtype=np.float64)
a
a.size  #  Общее количество элементов в массиве
a.itemsize  #  Размер одного элемента в байтах
a.size * a.itemsize




